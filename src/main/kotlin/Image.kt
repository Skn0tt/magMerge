/** Copyright (c) 2017 Simon Knott * * Permission is hereby granted, free of charge, to any person obtaining * a copy of this software and associated documentation files (the * "Software"), to deal in the Software without restriction, including * without limitation the rights to use, copy, modify, merge, publish, * distribute, sublicense, and/or sell copies of the Software, and to * permit persons to whom the Software is furnished to do so, subject to * the following conditions: * * The above copyright notice and this permission notice shall be * included in all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */import org.apache.pdfbox.pdmodel.PDDocumentimport org.apache.pdfbox.rendering.PDFRendererimport java.awt.Graphicsimport java.awt.image.BufferedImageimport java.io.Fileimport java.io.FileNotFoundExceptionimport java.io.IOExceptionimport javax.imageio.ImageIO/** * Created by skn0tt on 20.08.17. *//** * Merges a given PDF and renders pngs from it */fun merge (_inputPDF: String, _outputDir: String, issue: Int) {    // Check inputPDF    val inputPDF = File(_inputPDF)    if (!inputPDF.exists()) throw FileNotFoundException("Input Directory doesn't exist.")    // Correct outputDir    val outputDir = if (File(_outputDir).isDirectory) _outputDir else _outputDir + "/"    // Check outputDir    if (!File(outputDir).exists()) throw FileNotFoundException("Output Directory doesn't exist.")    // Get PNGs    val bufferedImages: List<BufferedImage> = getBufferedImagesForPDF(inputPDF)    // Export 1st    ImageIO.write(bufferedImages[0], "jpeg", newOutPutFile(1, issue, outputDir))    // Export rest    for (i in 1..bufferedImages.size step 2) {        //Last Page        if (i >= bufferedImages.size - 1) {            try {                ImageIO.write(bufferedImages[i],                        "jpeg",                        newOutPutFile(i + 1, issue, outputDir))            } catch (e: IOException) {}            break        }        // Normal Page        try {            ImageIO.write(mergeImages(bufferedImages[i], bufferedImages[i + 1]),                    "jpeg",                    newOutPutFileDual(i, issue, outputDir))        } catch (e: IOException) {}    }}fun getBufferedImagesForPDF(src: File) : List<BufferedImage> {    val doc: PDDocument = PDDocument.load(src)    val pdfRenderer = PDFRenderer(doc)    return (0 until doc.numberOfPages).map { pdfRenderer.renderImage(it) }}fun newOutPutFile(i: Int, issue: Int, outputDir: String) : File    = File(outputDir + "/" + issue + "-" + String.format("%02d", i) + ".jpg")fun newOutPutFileDual(i: Int, issue: Int, outputDir: String) : File    = File(outputDir + "/" + issue + "-" + String.format("%02d", i + 1) + ""  + String.format("%02d", i + 2) + ".jpg")/** * Takes two imgs and returns them horizontally merged. * @param img1 first Image * @param img2 second Image * @return Merged Images */fun mergeImages(img1: BufferedImage, img2: BufferedImage) : BufferedImage {    val result = BufferedImage(img1.width + img2.width, img1.height, BufferedImage.TYPE_INT_RGB)    val g: Graphics = result.graphics    g.drawImage(img1, 0,0, null)    g.drawImage(img2, img1.width, 0, null)    return result}